def solution(n):
    answer = 0
    while n != 0:
        answer += n % 2
        n = n//2
    return answer

"""
처음에 생각한 방법은 DP로 푸는거였다. 바로 이전의 값과 절반일때의 값을 비교하여 작은 값+1 을 가지고 가는거였는데
시간초과가 발생했다.
그래서 생각을 해보니 짝수는 무조건 순간이동을 해서 왔다고 생각하면 최솟값이 나오는 것이다.
따라서 반복문을 이용해 풀어보니 시간초과도 뜨지 않았다.

+ 다른사람의 코드를 보니 이진화를 시킨후 1을 세는 식으로 푼사람이 있었다.
백준에 비슷한 문제가 있던것 같은데...

+ 찾아보니 1094 막대기 라는 문제였다.
보는 관점을 살짝 달리한 문제인데 좀더 문제 분석력을 키워야겠다.
"""